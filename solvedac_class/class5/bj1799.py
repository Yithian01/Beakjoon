# d=0 (0, 0) <------------------------------------ 위 -> 아래, 오른 -> 왼쪽으로 가는 대각선을 나타냄
# d=1 (0, 1), (1, 0) 
# d=2 (0, 2), (1, 1), (2,0)
# d=3 (0, 3), (1, 2), (2, 1), (3, 0)
# d=4 (0, 4), (1, 3), (2, 2), (3, 1), (4, 0)
# d=5 (0, 5), (1, 4), (2, 3), (3, 2), (4, 1), (5, 0)
# d=6 (0, 6), (1, 5), (2, 4), (3, 3), (4, 2), (5, 1), (6, 0)
# d=7 (0, 7), (1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1), (7, 0)
# d=8 (0, 8), (1, 7), (2, 6), (3, 5), (4, 4), (5, 3), (6, 2), (7, 1), (8, 0)
# d=9 (0, 9), (1, 8), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3), (7, 2), (8, 1), (9, 0)

# <-------------------- in_range()함수를 사용해서 matrix에서 벗어나는 노드를 제거하면??? n =5일 때 -------------------->
# d=0 (0, 0) 
# d=1 (0, 1), (1, 0) 
# d=2 (0, 2), (1, 1), (2,0)
# d=3 (0, 3), (1, 2), (2, 1), (3, 0)
# d=4 (0, 4), (1, 3), (2, 2), (3, 1), (4, 0)
# d=5 (1, 4), (2, 3), (3, 2), (4, 1)
# d=6 (2, 4), (3, 3), (4, 2)
# d=7 (3, 4), (4, 3)
# d=8 (4, 4)
# d=9   X  

# 처음 upper_bound()를 통해서 각 단계에서 될 수 있는 최대 값을 알 수 있음 최대 2*n - 1개 가 가능함 
#
#rd= {-4: 0, -3: 0, -2: 0, -1: 0, 0: 0, 1: 0, 2: 0, 3: 0, 4: 0}
#c-r
# <------------------------------------ 위 -> 아래, 왼 --> 오른쪽으로 가는 대각선을 나타냄
#
# 0
# 1, -1
# 2, 0, -2
# 3, 1, -1, -3
# 4, 2, 0, -2, -4
# 3, 1, -1, -3
# 2, 0, -2
# 1, -1
# 0

#  0   1   2   3   4
#
# -1   0   1   2   3
#
# -2  -1   0   1   2
#
# -3  -2  -1   0   1
#
# -4  -3  -2  -1   0 

# 비숍이 가능한가는 2가지에 의해서 결정된다.
# 1) 좌상향, 우하향 대각선에 다른 것이 있는지
# 2) 우상향, 좌하향 대각선에 다른 것이 있는지 

# 함수 upper_bound() 는 (2)번 조건에 따라 움직인다.
# rd <--- (1)번 규칙을 지키고 있는지 확인한다.

# 현재 들어온 좌하향 대각선부터 ~~~ 끝까지 간다면 얻을 수 있는 최대량이 현재 ans보다 적다면 푸르닝 
# 현재 좌햐향 그래프가 (1), (2)번 조건을 모두 충족한다면 rd[c-r]의 값을 1올리고 다음 좌햐향 그래프, cnt +1 을 해서 재귀

# st  => 현재 좌하향 그래프
# cnt => 현재까지 놓을 수 있는 비숍 수 

# 시간복잡도 계산: O(10^(19//2)) --> 최대 10 * 2 -1만큼 재귀가 이루어져야 하지만, 위에서 보듯 푸르닝을 통해 가망이 없는 재귀는 반환된다. 그러므로 절반이상 반환되므로 10^8승 아래로 예상된다.
import sys
input = sys.stdin.readline
in_range = lambda r, c : 0 <= r < n and 0 <= c < n # 범위 조절 함수

def upper_bound( st): 
    tmp = 0
    for d in range( st, 2 * n - 1):
        for r in range(d+1):
            c = d - r 
            if in_range(r, c) and ma[r][c] and rd[c - r] == 0:
                tmp += 1
                break
    
    return tmp

def sol(st, cnt): 
    global ans
    if st == 2 * n:                                        # 여기까지 오는 최대 경우의 수는 먼저 만나는 둘 수 있는 곳은 모두 둔 형태 
        ans = max(ans, cnt)                                
        return
    
    ub = upper_bound(st)
    if ub + cnt <= ans:  # 푸르닝                            위의 처음만나는 곳을 모두 둔 경우의 수보다 적은 경우는 보지 않아도 된다.
        return 
    
    for r in range(st + 1): # 우상향에서 좌하향으로 본다.
        c = st - r
        if in_range(r, c) and ma[r][c] and rd[c - r] == 0: # rd를 통과하면 좌상향에서 우하향도 본 것 
            rd[c - r] = 1                                  # 현재 좌상향 우하향을 체크하고 
            sol(st + 1, cnt +1)                            # 다음 직선, 비숍 + 1하고 재귀
            rd[c - r] = 0                                  # 현재 비숍을 두지 않는 경우의 수 계산하기 때문에 다시 제거 

    sol(st + 1, cnt)                                       # 비숍을 두지 않았을 경우 재귀


n = int(input())
ma = [list(map(int, input().split())) for _ in range(n)]

rd = {}
for i in range(-n+1, n):
    rd[i] = 0

    
ans = 0
sol(0, 0)
print(ans)