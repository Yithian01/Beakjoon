# 거꾸로 가며 dp테이블을 업데이트 한다.
# [15][15] => 백15, 흑15개를 최적으로 했을 때를 말한다.
# [0][1] => 백은 선택하지 않고 흑1개를 선택했을 때 최대값 

# 백 흑 
# 87 84 가 들어오면 [15, 15] 와 [14, 15] + 87을 비교한다.
# -> 흰색 14개 + 현재 백 과 흑15개의 최대값  
# -> 흰색 13개 + 현재 백 과 흑15개의 최대값
# -> 흰색 12개 + 현재 백 과 흑15개의 최대값
# ... // 백으로 쓰이는 경우의 수를 계속 업데이트 해준다.
# -> 흰색 15개 + 현재 흑 과 흑14개의 최대값  
# -> 흰색 15개 + 현재 흑 과 흑13개의 최대값
# -> 흰색 15개 + 현재 흑 과 흑12개의 최대값
# ... // 백으로 쓰이는 경우의 수를 계속 업데이트 해준다.

# 다음과 같이 업데이트 될 것이다.
# - dp[0][1] => 백0개 흑1개를 쓸 경우 최대값
# - dp[1][0] => 백1개 흑0개를 쓸 경우 최대값 

# 87 84 ---> 이 경우 dp[0][1] = 84 dp[1][0] = 87 
# 66 78 ---> dp[0][1] = 84, dp[1][0] = 87 처음과 바뀌지 않은 것을 볼 수 있다. 하지만
#            dp[1][1] = 165가 된다. 
#            dp[1][0] + 78 => 백1개 썼는데 최고값은 84 + 78 => 165  
#            dp[0][1] + 66 => 흑1개 썼는데 최고값은 84 + 66 => 150 
#     각 경우의 수의 최고값을 얻을 수 있다.

# 시간 복잡도 계산: 2 * 10^2 * N => O(N)
import sys
input = sys.stdin.readline

# i:흰색팀, j:검은색팀
dp = [[0] * 16 for _ in range(16)]

while True:
    try:
        a, b = map(int, input().split())
        for i in range(15, -1, -1):
            for j in range(15, -1, -1):
                if i != 0:
                    dp[i][j] = max(dp[i][j], dp[i-1][j] + a)
                
                if j != 0:
                    dp[i][j] = max(dp[i][j], dp[i][j-1] + b)
        
    except:
        print(dp[15][15])
        break
